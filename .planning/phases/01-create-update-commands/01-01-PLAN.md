---
phase: 01-create-update-commands
plan: 01
type: execute
depends_on: []
files_modified: [src/client/index.ts, src/client/types.ts, src/commands/workflows.ts]
---

<objective>
Add `workflows create` and `workflows update` commands with JSON file input.

Purpose: Enable users to create new workflows and update existing ones by providing workflow JSON from files, completing the write operations of the workflow CRUD.
Output: Two new CLI commands (`create`, `update`) that read workflow JSON from files and call the n8n API.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

**Source files to reference:**
@src/commands/workflows.ts
@src/client/index.ts
@src/client/types.ts
@src/utils/client.ts

**Established patterns:**
- Command registration via `registerWorkflowCommands(program)`
- Client methods use private `request<T>(method, endpoint, data)`
- Output via `formatOutput(data, format, type)`
- Debug logging via `debug(globalOpts, message)`

**n8n API endpoints:**
- POST /workflows — create workflow (body: workflow JSON without id)
- PUT /workflows/:id — update workflow (body: workflow JSON)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add client methods for create and update workflows</name>
  <files>src/client/index.ts, src/client/types.ts</files>
  <action>
    In src/client/types.ts:
    - Add `WorkflowCreateInput` interface: Omit<N8nWorkflow, 'id' | 'createdAt' | 'updatedAt'> with name required, nodes/connections/settings/tags optional
    - Add `WorkflowUpdateInput` interface: Partial<WorkflowCreateInput> & { name?: string }

    In src/client/index.ts:
    - Add `createWorkflow(data: WorkflowCreateInput): Promise<N8nWorkflow>` method
      - POST to `/workflows` with data
      - Return created workflow
    - Add `updateWorkflow(id: string, data: WorkflowUpdateInput): Promise<N8nWorkflow>` method
      - PUT to `/workflows/${id}` with data
      - Return updated workflow

    Follow existing method patterns (see listWorkflows, getWorkflow).
  </action>
  <verify>npm run build succeeds without TypeScript errors</verify>
  <done>Two new client methods exist: createWorkflow() and updateWorkflow(), both properly typed</done>
</task>

<task type="auto">
  <name>Task 2: Add workflows create command</name>
  <files>src/commands/workflows.ts</files>
  <action>
    Add `workflows create` subcommand:
    - Required option: `--file <path>` or `-f <path>` for workflow JSON file
    - Optional: `--json` flag for JSON output

    Implementation:
    1. Import `fs` from 'node:fs/promises' and `path` from 'node:path'
    2. Read file using fs.readFile with utf-8 encoding
    3. Parse JSON with try/catch, throw descriptive error on parse failure
    4. Call client.createWorkflow(data)
    5. Output result using formatOutput(workflow, format, 'workflow')

    Error handling:
    - File not found: "File not found: <path>"
    - JSON parse error: "Invalid JSON in file: <parse error message>"
    - API errors handled by existing error infrastructure

    Follow existing command patterns from `list` and `get` commands.
  </action>
  <verify>npm run build succeeds; npm run cli -- workflows create --help shows --file option</verify>
  <done>Command `workflows create --file <path>` is registered and shows in help</done>
</task>

<task type="auto">
  <name>Task 3: Add workflows update command</name>
  <files>src/commands/workflows.ts</files>
  <action>
    Add `workflows update` subcommand:
    - Required argument: `<id>` for workflow ID
    - Required option: `--file <path>` or `-f <path>` for workflow JSON file
    - Optional: `--json` flag for JSON output

    Implementation:
    1. Read file using fs.readFile (reuse pattern from create command)
    2. Parse JSON with try/catch
    3. Call client.updateWorkflow(id, data)
    4. Output result using formatOutput(workflow, format, 'workflow')

    Same error handling as create command.
    Follow existing command patterns from `get` command for argument handling.
  </action>
  <verify>npm run build succeeds; npm run cli -- workflows update --help shows id argument and --file option</verify>
  <done>Command `workflows update <id> --file <path>` is registered and shows in help</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run cli -- workflows create --help` shows --file option
- [ ] `npm run cli -- workflows update --help` shows id argument and --file option
- [ ] No TypeScript errors in modified files
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Commands registered and accessible via CLI help
- Client methods properly typed and follow existing patterns
</success_criteria>

<output>
After completion, create `.planning/phases/01-create-update-commands/01-01-SUMMARY.md`:

# Phase 1 Plan 01: Create & Update Commands Summary

**[One-liner describing what was accomplished]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `src/client/types.ts` - Added WorkflowCreateInput and WorkflowUpdateInput interfaces
- `src/client/index.ts` - Added createWorkflow() and updateWorkflow() methods
- `src/commands/workflows.ts` - Added create and update subcommands

## Decisions Made

[Any decisions made during implementation, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 1 complete, ready for Phase 2: State Operations
</output>
